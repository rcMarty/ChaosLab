import numpy as np
import matplotlib.pyplot as plt
from matplotlib.axes import Axes
from src.utils.neural_helpers import Runnable
from src.utils.visualization import plot_fractal_paths


class LSystem(Runnable):
    """
    Generator of fractals using L-systems.
    """

    def __init__(self, axiom: str = "F", rules: dict = None, angle: float = 90, iterations: int = 3, step_length: float = 1.0):
        """
        Initialize L-system parameters.

        :param axiom: Starting string for pattern generation
        :param rules: Dictionary of replacement rules (key: character, value: replacement string)
        :param angle: Turning angle in degrees for +/- commands
        :param iterations: Number of string rewriting iterations
        :param step_length: Drawing distance for 'F' command
        """
        self.axiom = axiom
        self.rules = rules or {"F": "F+F-F-F+F"}
        self.angle = np.radians(angle)
        self.iterations = iterations
        self.step_length = step_length
        self.paths = []

    def generate(self):
        """
        Generate final command string through iterative rewriting.

        :return: Final string containing drawing commands after all iterations
        """
        current = self.axiom
        for _ in range(self.iterations):
            current = "".join([self.rules.get(c, c) for c in current])
        return current

    def _build_paths(self, commands: str):
        """
        Convert command string to geometric paths with turtle graphics logic.
        Handles branching through stack-based state management.

        :param commands: String generated by L-system rules containing drawing commands
        :return: None
        """
        self.paths = []
        state_stack = []
        current_path = []
        x, y, direction = 0.0, 0.0, 0.0  # Initial position and heading

        for cmd in commands:
            if cmd == "F":
                new_x = x + self.step_length * np.cos(direction)
                new_y = y + self.step_length * np.sin(direction)
                current_path.append([x, y])
                x, y = new_x, new_y
            elif cmd == "+":
                direction += self.angle  # Turn left
            elif cmd == "-":
                direction -= self.angle  # Turn right
            elif cmd == "[":
                state_stack.append((x, y, direction))  # Push current state
            elif cmd == "]":
                if state_stack:
                    current_path.append([x, y])
                    self.paths.append(np.array(current_path))
                    x, y, direction = state_stack.pop()  # Restore previous state
                    current_path = [[x, y]]

        if current_path:
            self.paths.append(np.array(current_path))  # Add remaining points after command processing

    def visualize(self, **kwargs):
        commands = self.generate()
        self._build_paths(commands)
        return plot_fractal_paths(self.paths, **kwargs)

    @staticmethod
    def run():
        # Příklady různých fraktálů
        systems = [
            (LSystem(axiom="F", rules={"F": "F+F-F-F+F"}, angle=90, iterations=3),
             {"title": "Kochova Křivka", "save": True}),

            (LSystem(axiom="X", rules={"X": "F+[[X]-X]-F[-FX]+X", "F": "FF"}, angle=25, iterations=5),
             {"title": "Fraktální Strom", "save": True}),

            (LSystem(axiom="F--F--F", rules={"F": "F+F--F+F"}, angle=60, iterations=4),
             {"title": "Sierpińského Trojúhelník", "save": True})
        ]

        for system, params in systems:
            system.visualize(**params)
            plt.show()
